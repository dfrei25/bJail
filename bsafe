#!/usr/bin/env bash
#
# bsafe: rootless script to sandbox applications using bwrap, importing/using official firejail rule sets. Now also supports seccomp filtering.
#
# see --help/show_help() for usage and examples


# adjust this in case you want to use your locally installed firejail profile directory (optional) to import a wider set of whitelist rules
firejail_profile_dir="/etc/firejail"


#### global variables/arrays

# array for files with read/write access and environment variables
declare -a rw_files ro_files env_vars
# array that will store all final arguments for bwrap
declare -a bwrap_args=()
# optional runtime switches, see help
declare dryrun verbose use_seccomp
# the set of permissions to be served to the application
declare application_profile=""
# the main firejail profile for the application
declare firejail_profile=""
# command running in bwrap sandbox...
declare executable=""
# ...and it's arguments
declare -a command_arguments=()


#### functions

show_help() {
  cat << EOF
Usage: $0 [option] command args

Options:
  -h, --help               # print this help
  -d, --dryrun             # print the bwrap command that would be executed and exit
  -v, --verbose            # more output
  -p=name, --profile=name  # manual select a profile
  -s, --seccomp            # use seccomp to block system calls, based on profiles
  -l, --seccomp-log        # like -s, but log prohibited syscalls from blacklist
                           # to dmesg (useful/needed when building/fixing profiles)
                           # missing-syscall-helper.sh will help you.

Examples:
  $0 firefox google.com    # Open google.com in sandboxed firefox
  $0 -s steam              # Start sandboxed steam with syscall blacklist active
  $0 -s strace ls          # Verify seccomp rules (not permitted error)
  $0 -l strace ls          # Debug seccomp rules (success) -> audit message in dmesg
  $0 -p=firefox dolphin    # Open Dolphin with firefox profile to
                           # verify what files firefox would be able to see
  $0 -d discord            # Show discord launch command, but do not start discord
  $0 -d -s discord         # As above, but also show active seccomp blacklist
  $0 bash                  # Start sandboxed shell
EOF
}

# check if requirements are met or exit
validate_requirements() {
  # Is bwrap command available?
  if ! command -v bwrap &>/dev/null; then
    echo "Error: bubblewrap (bwrap) is not installed or not in PATH"
    exit 1
  fi
  # Change directory to where bJail is located
  if ! cd -- "$(dirname -- "$( realpath -- "${BASH_SOURCE[0]}" )")" &> /dev/null;then
    echo "Failed to change to script directory"
    exit 1
  fi
}

# argument handling, see help
parse_userinput() {
  # no arguments provided
  [[ $# -eq 0 ]] && echo "Error: No command specified" >&2 && show_help && exit 1
  
  # 1) parse bJail arguments
  for i in "$@"; do
    case $i in
      -h|--help)
        show_help && exit 0
        ;;
      -p*|--profile*)
        application_profile="${1#*=}"
        shift # next argument
        ;;
      -s|--seccomp)
        use_seccomp="block"
        shift
        ;;
      -l|--seccomp-log)
        use_seccomp="log"
        shift
        ;;
      -d|--dryrun)
        dryrun=1
        shift
        ;;
      -v|verbose)
        verbose=1
        shift
        ;;
      *)
        # when all options are processed, break
        break
        ;;
    esac
  done

  # 2) parse executable, check if it is valid
  if command -v "$1" >/dev/null 2>&1; then
    executable="$1"
    shift
  else
    echo "Error: Command \"""$1""\" is not installed or not in PATH"
    exit 1
  fi

  # assign the rest of the user input as commands arguments
  command_arguments=("${@}")
}

# Remove a list of items from a given array (removing blacklisted items)
#
# Example: arr1=(a b c d e); rm_arr=(b d); remove_items_from_array arr1 "${rm_arr[@]}"; echo ${arr1[@]} -> a c e
remove_items_from_array(){
  local -n arrayref="$1"
  shift

  for item in "$@";do
    for i in "${!arrayref[@]}";do
      [[ ${arrayref[i]} == "$item" ]] && unset 'arrayref[i]'
    done
  done
}

# Load firejail .profile files recursively
load_firejail_profile_path(){
  local profile_path="$1"

  [[ -n $verbose ]] && echo "Loading firejail profile $profile_path"
  resolve_glob(){
    local file glob=$1 IFS=
    shift

    for file in $glob;do
      [[ -r $file ]] && "$@" "$file"
    done
  }
  rw_file_add(){
    rw_files+=("$1")
  }
  ro_file_add(){
    ro_files+=("$1")
  }

  ! [[ -r "$profile_path" ]] && return 1
  
  IFS=' '; while read -r directive argument;do
    # skip parsing commented lines
    if [[ $directive != '#'* ]];then
      # Strip off any trailing comments.
      # XXX Does not trim trailing whitespace.
      argument=${argument%%#*}

      # XXX add videos and other firejail variables
      argument=${argument/\$\{HOME\}/$HOME}
      argument=${argument/\$\{RUNUSER\}/$XDG_RUNTIME_DIR}
      argument=${argument/\$\{DOWNLOADS\}/$HOME\/Downloads}

      # Remove all non-portable characters.
      # XXX This sort of thing should be minimised or removed if
      #     possible.
      #argument=${argument//[!a-zA-Z0-9\/.-\*\[\]\$\{\}\:+_\?]}
      #argument="$(tr -cd 'a-zA-Z0-9/.\-\*[]${}:+_?\ \n' <<<"$argument")" # fixme: replace tr with bash expensions


      case $directive in
        include)
          resolve_glob "$firejail_profile_dir/$argument" load_firejail_profile_path ;;
        whitelist)
          resolve_glob "$argument" rw_file_add ;;
        read-only)
          resolve_glob "$argument" ro_file_add ;;
        whitelist-ro)
          resolve_glob "$argument" ro_file_add ;;
        # seccomp) #todo
      esac
    fi
  done < "$profile_path"
}

# build the final bwrap arguments
build_bwrap_args_array() {
  local sorted_unique line
  
  # TODO: deduplicate code
  # 1) Process read-write files
  if [[ ${#rw_files[@]} -gt 0 ]]; then
    # Deduplication using sort -u
    sorted_unique=$(printf '%s\n' "${rw_files[@]}" | sort -u)
    while IFS= read -r line; do
      # no file provided or it doesn't exist/is not readable
      [[ -z "$line" || ! -r "$line" ]] && continue
      bwrap_args+=(--bind "$line" "$line")
    done <<< "$sorted_unique"
  fi
  
  # 2) Process read-only files
  if [[ ${#ro_files[@]} -gt 0 ]]; then
    # Deduplication using sort -u
    sorted_unique=$(printf '%s\n' "${ro_files[@]}" | sort -u)
    while IFS= read -r line; do
      # no file provided or it doesn't exist/is not readable
      [[ -z "$line" || ! -r "$line" ]] && continue
      bwrap_args+=(--ro-bind "$line" "$line")
    done <<< "$sorted_unique"
  fi

  # 3) Process environment variables
  # FIXME: Currently breaks in case envvar contains spaces
  local var
  for var in "${env_vars[@]}"; do
    [[ -n "${!var:-}" ]] && bwrap_args+=(--setenv "$var" "${!var}")
  done
}

# build the filter.bpf file, used by bwrap
gen_bpf_filter(){
  # first build the cBPF generator (helper tool to generate seccomp cBPF files)
  # when it does not exist yet, see gen-filter.cpp for source code
  if ! [[ -r ./gen-filter ]];then
    if echo '#include <seccomp.h>' | g++ -x c++ - -c -o /dev/null &>/dev/null; then
      make
    else
      echo seccomp.h from libseccomp is available, cannot create seccomp filters.
      unset use_seccomp
      return 1
    fi
  fi

  local modeflag
  case $use_seccomp in
    log)
      modeflag='-l'
      ;;
    block)
      modeflag='-b'
      ;;
  esac
  ./gen-filter $modeflag ${seccomp_blacklist[@]}
}


#### Profile categories

# drop as much as possible. The whole script is bottom-up designed
restrict_everything() {
  bwrap_args+=(
    # drop all capabilities by default. This should be bwrap default, however
    --cap-drop ALL
    # unshare all namespaces by default
    --unshare-user
    --unshare-ipc
    --unshare-pid
    --unshare-net
    --unshare-uts
    --unshare-cgroup
    # disconnect from terminal, so sandbox can't inject input into the terminal
    --new-session
    # Ensures child process (COMMAND) dies when bwrap's parent dies (SIGKILL)
    --die-with-parent
    --clearenv
  )
}

# essential/general stuff to run most applications
allow_basics() {
  bwrap_args+=(
    --proc /proc
    --dev-bind /dev /dev # might wanna be more restrictive here
    --tmpfs /tmp
    --tmpfs /run
    --tmpfs /home
    --symlink usr/lib /lib
    --symlink usr/lib64 /lib64
    --symlink usr/bin /bin
    --symlink usr/bin /sbin
  )
  ro_files+=(
    /etc
    /sys
    /usr
    /opt
  )
  rw_files+=("$HOME/Downloads") # always available
  env_vars+=(
    "PATH"
    "HOME"
    "JAVAC"
    "JAVA_HOME"
    "JDK_HOME"
    "LANG"
    "LC_COLLATE"
    "LC_MESSAGES"
    "LOGNAME"
    "USER"
    "XDG_CONFIG_DIRS"
    "XDG_CONFIG_HOME"
    "XDG_DATA_DIRS"
    "XDG_RUNTIME_DIR"
    "XDG_SESSION_CLASS"
  )
}

allow_sound() {
  rw_files+=(
    "$HOME/.config/pulse"
    "$XDG_RUNTIME_DIR/pipewire-0"
    "$XDG_RUNTIME_DIR/pipewire-0.lock"
    "$XDG_RUNTIME_DIR/pulse"
  )
}

allow_net() {
  bwrap_args+=(--share-net)
  ro_files+=(
    "/run/systemd/resolve"
    "/etc/resolv.conf"
    "/etc/nsswitch.conf"
    "/run/NetworkManager/resolv.conf"
  )
}

allow_gui() {
  env_vars+=(
    "DISPLAY"
    "GDK_BACKEND"
    "GSETTINGS_BACKEND"
    "GTK2_RC_FILES"
    "GTK_THEME"
    "GTK_USE_PORTAL"
    "LIBVA_DRIVERS_PATH"
    "LIBVA_DRIVER_NAME"
    "QT_QPA_PLATFORM"
    "QT_STYLE_OVERRIDE"
    "SDL_VIDEODRIVER"
    "WAYLAND_DISPLAY"
    "XCURSOR_SIZE"
    "XCURSOR_THEME"
    "XDG_CURRENT_DESKTOP"
    "XDG_MENU_PREFIX"
    "XDG_SEAT"
    "XDG_SESSION_DESKTOP"
    "XDG_SESSION_ID"
    "XDG_SESSION_TYPE"
    "XDG_VTNR"
    "MESA_VK_DEVICE_SELECT"
  )
  ro_files+=(
    "$HOME/.Xauthority"
    "$XDG_CONFIG_HOME/mimeapps.list" # doesn't really belong here
  )
  rw_files+=(
    "$XDG_RUNTIME_DIR/wayland-1"
    "$XDG_RUNTIME_DIR/wayland-1.lock"
    "/tmp/.X11-unix/X0"
  )
}

allow_dbus() {
  env_vars+=(
    "DBUS_SESSION_BUS_ADDRESS"
    "I3SOCK"
    "SWAYSOCK"
  )

  if [[ -n "${DBUS_SESSION_BUS_ADDRESS:-}" ]]; then
    rw_files+=("${DBUS_SESSION_BUS_ADDRESS//unix:path=/}")
  fi
  
  local atspi_dir="$XDG_RUNTIME_DIR/at-spi"
  [[ ! -d "$atspi_dir" ]] && mkdir -p "$atspi_dir" && rw_files+=("$atspi_dir")
  [[ -e /run/dbus/system_bus_socket ]] && rw_files+=(/run/dbus/system_bus_socket)
  [[ -d "$XDG_RUNTIME_DIR/dbus-1" ]] && rw_files+=("$XDG_RUNTIME_DIR/dbus-1")
  [[ -e "$XDG_RUNTIME_DIR/bus" ]] && rw_files+=("$XDG_RUNTIME_DIR/bus")
}

allow_term() {
  ro_files+=("$HOME/.zshrc")
  env_vars+=(
    "COLORTERM"
    "EDITOR"
    "INFOPATH"
    # "LESS"
    # "LESSOPEN"
    "LEX"
    "MANPAGER"
    "MANPATH"
    "MOTD_SHOWN"
    "NNN_FIFO"
    "NNN_PLUG"
    "OLDPWD"
    "PAGER"
    "PATH"
    "PWD"
    "SHELL"
    "SHLVL"
    "TERM"
    "TERMINFO_DIRS"
  )
}

allow_rwhome() {
  rw_files+=(
    "$HOME"
  )
}

# Use the same namespace as the real user
allow_userns() {
  remove_items_from_array bwrap_args "--unshare-user" 
}

allow_games() {
  local env_vars+=(
    "DXVK_ASYNC"
    "STEAM_RUNTIME"
    "STEAM_RUNTIME_PREFER_HOST_LIBRARIES"
    "WINEDEBUG"
    "PROTON_ENABLE_WAYLAND"
  )
  rw_files+=(
    "$HOME/.local/Terraria"
    "$HOME/.factorio"
  )
}

# profile sync daemon
allow_psd() {
  rw_files+=("$XDG_RUNTIME_DIR/psd")
}


#### seccomp profiles, wip.
# Currently using a long but commented blacklist (see syscall_blacklist.inc.sh)
# using all jirejail entities but removed ones plus a few other critical ones
# run tools/compare_firejail_blacklist.sh for details
syscalls_ipc=(msgctl msgget msgrcv msgsnd shmctl shmdt shmget shmat semctl semget semop semtimedop)


#### permission settings per app
load_application_profile(){
  case $application_profile in
    steam)
      allow_gui
      allow_sound
      allow_dbus
      allow_net
      allow_games
      seccomp_whitelist+=(pivot_root mount umount2)
      ;;
    zsh)
      allow_gui
      allow_sound
      allow_net
      allow_term
      ro_files+=("$HOME/.zshrc")
      bwrap_args+=(--setenv PS1 "\(bwrap\)\$PS1") # sandbox indicator
      ;;
    discord)
      allow_gui
      allow_sound
      allow_dbus
      allow_net
      allow_sound
      rw_files+=("$HOME/.config/discord")
      ro_files+=(/opt/discord)
      seccomp_whitelist+=(unshare chroot)
      ;;
    google-chrome-stable)
      allow_gui
      allow_sound
      allow_net
      ;;
    firefox)
      allow_gui
      allow_sound
      allow_dbus
      allow_net
      allow_psd  # profile-sync-daemon
      env_vars+=(
        "MOZ_DRM_DEVICE"
        "MOZ_GMP_PATH"
      )
      firejail_profile="firefox-esr"
      seccomp_whitelist+=(unshare chroot kcmp)
      ;;
    hexchat)
      allow_gui
      allow_sound
      allow_dbus
      allow_net
      ;;
    untrusted)
      seccomp_blacklist+=("${syscalls_ipc[@]}" socket mprotect pkey_mprotect)
      bwrap_args+=(--disable-userns) # sets user.max_user_namespaces=1
      ;;      
    *)
      return 1
      ;;
  esac
  
  # Remove the whitelisted syscalls from blacklist
  remove_items_from_array seccomp_blacklist "${seccomp_whitelist[@]}"
}


######## Main execution ########

# check if requirements are met and arguments are correct
validate_requirements

# apply options like "showcommand" and seperate them from executable and command_arguments
parse_userinput "${@}"

# when desired, load seccomp related functions and populate seccomp blacklist
[[ -n $use_seccomp ]] && source syscall_blacklist.inc.sh

# block everything first, we start from scratch
restrict_everything

# load "fundamental" permissions, like accessing /usr/bin
allow_basics

# when no application profile got manually selected, default to command
if [[ -z $application_profile ]];then
  application_profile="${executable}"
fi

# when no firejail profile got manually selected, default to application profile
if [[ -z $firejail_profile ]];then
  firejail_profile="${application_profile}"
fi

# load application profile (if existing)
load_application_profile

# load firejail profile (if existing)
load_firejail_profile_path "$firejail_profile_dir/$firejail_profile.profile"

# build final bwrap argument list
build_bwrap_args_array

# Print or run the command
if [[ $dryrun ]]; then
  printf '\nThe following command would be executed:\n\n'

  if [[ $use_seccomp ]]; then
    printf 'bwrap --seccomp 10 %s %s %s 10< filter.bpf\n\n' "${bwrap_args[*]}" "${executable}" "${command_arguments[*]}"
    printf 'Seccomp blacklist:\n\n%s\n' "${seccomp_blacklist[*]}"
  else
    printf 'bwrap %s %s %s' "${bwrap_args[*]}" "${executable}" "${command_arguments[*]}"
  fi
else
  # fd 9 is used to pass bwrap_args
  if [[ $use_seccomp ]]; then
    gen_bpf_filter 1>/dev/null # generate the seccomp filter cbpf file based on our blacklist silent
    (sleep 5 && rm /tmp/filter.bpf 2> /dev/null)&
    bwrap --args 9 --seccomp 10 "${executable}" "${command_arguments[@]}" 9< <(printf '%s\0' "${bwrap_args[@]}") 10< /tmp/filter.bpf
  else
    bwrap --args 9 "${executable}" "${command_arguments[@]}" 9< <(printf '%s\0' "${bwrap_args[@]}")
  fi
fi
